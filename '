
#include "cuda_runtime.h"
#include "device_launch_parameters.h"

#include <chrono>
#include <stdio.h>
#include <time.h>
#include <stdlib.h>
#include <math.h>

const int N = 2137;
const int R = 16;
const int K = 4;

const int BLOCK_SIZE = 16;

const int OUTSIZE = N - 2 * R;

cudaError_t addWithCuda(int *c, const int *a, const int *b, unsigned int size);
cudaError_t sumLocalWithCuda(float *tab, float *out);

__global__ void addKernel(int *c, const int *a, const int *b)
{
    int i = threadIdx.x;
    c[i] = a[i] + b[i];
}

__global__ void localKernelOld(float* tab, float* out)
{
    int i = (threadIdx.x + blockIdx.x * blockDim.x);
    int j = (threadIdx.y + blockIdx.y * blockDim.y) * K;

    for (int k = 0; k < K; k++) {
        float sum = 0;
        if (j + k < OUTSIZE) {
            for (int y = 0; y <= 2 * R; y++) {
                int jyk = (j + y + k)*N;
                for (int x = 0; x <= 2 * R; x++) {
                    sum += tab[jyk + (i + x)];
                }
            }
            out[(j + k) * (OUTSIZE) + i] = sum;
        }
    }
}

__global__ void localKernel(float* tab, float* out)
{
    int i = (threadIdx.x + blockIdx.x * blockDim.x) * K;
    int j = (threadIdx.y + blockIdx.y * blockDim.y);

    for (int k = 0; k < K; k++) {
        float sum = 0;
        if (i + k < OUTSIZE) {
            for (int y = 0; y <= 2*R; y++) {
                int jy = (j + y)*N;
				for (int x = 0; x <= 2*R; x++) {
					sum += tab[jy + (i + x + k)];
				}
            }
            out[(j) * (OUTSIZE) + i + k] = sum;
        }
    }
}

void sequential(float tab[N*N], float out[(N-2*R)*(N-2*R)])
{
	for (int i = R; i < N - R; i++) {
		for (int j = R; j < N - R; j++) {
			float sum = 0;
			for (int x = i - R; x <= i + R; x++) {
				for (int y = j - R; y <= j + R; y++) {
					sum += tab[x * N + y];
				}
			}
			out[(i - R) * (N - 2 * R) + j - R] = sum;
		}
	}
}

void print(float tab[N*N])
{
    for (int j = 0; j < N; j++) {
        for (int i = 0; i < N; i++) {
            printf("%f\t", tab[j * N + i]);
        }
        printf("\n");
    }
}

void print_out(float tab[(N-2*R)*(N-2*R)])
{
    for (int j = 0; j < N-2*R; j++) {
        for (int i = 0; i < N-2*R; i++) {
            printf("%f\t", tab[j * (N - 2 * R) + i]);
        }
        printf("\n");
    }
}

int main()
{
    srand(time(NULL));

    float* tab = (float*)malloc(N * N * sizeof(float));
    

    for (int j = 0; j < N; j++) {
        for (int i = 0; i < N; i++) {
            tab[j*N + i] = rand() % 10;
        }
    }
    
    float* out_seq = (float*)malloc(OUTSIZE * OUTSIZE * sizeof(float));

    auto start = std::chrono::high_resolution_clock::now();
    sequential(tab, out_seq);
    auto end = std::chrono::high_resolution_clock::now();
    auto timeSeq = std::chrono::duration_cast<std::chrono::microseconds>(end - start);
    printf("\nSeq: %.20f\n", timeSeq.count() / 1000.0f);

    float* out_local = (float*)malloc(OUTSIZE * OUTSIZE * sizeof(float));
    start = std::chrono::high_resolution_clock::now();
    sumLocalWithCuda(tab, out_local);
    end = std::chrono::high_resolution_clock::now();
    timeSeq = std::chrono::duration_cast<std::chrono::microseconds>(end - start);
    printf("\nLocal: %.20f\n", timeSeq.count() / 1000.0f);

    //print_out(out_seq);
    //printf("\n\n");
    //print_out(out_local);

	bool success = true;
    for (int i = 0; i < OUTSIZE * OUTSIZE; i++) {
        if (out_seq[i] != out_local[i]) {
           success = false;
        }
    }
    if (!success) {
        printf("FAILED!\n");
    }

    const int arraySize = 5;
    const int a[arraySize] = { 1, 2, 3, 4, 5 };
    const int b[arraySize] = { 10, 20, 30, 40, 50 };
    int c[arraySize] = { 0 };
}

cudaError_t sumLocalWithCuda(float* tab, float* out) 
{
    float* dev_tab = 0;
    float* dev_out = 0;
    cudaError_t cudaStatus;

    cudaStatus = cudaSetDevice(0);
    if (cudaStatus != cudaSuccess) {
        fprintf(stderr, "cudaSetDevice failed!  Do you have a CUDA-capable GPU installed?");
        goto Error;
    }

    cudaStatus = cudaMalloc((void**)&dev_tab, N * N * sizeof(float));
    if (cudaStatus != cudaSuccess) {
        fprintf(stderr, "cudaMalloc failed!");
        goto Error;
    }

    cudaStatus = cudaMalloc((void**)&dev_out, (OUTSIZE) * (OUTSIZE) * sizeof(float));
    if (cudaStatus != cudaSuccess) {
        fprintf(stderr, "cudaMalloc failed!");
        goto Error;
    }

    cudaStatus = cudaMemcpy(dev_tab, tab, N*N * sizeof(float), cudaMemcpyHostToDevice);
    if (cudaStatus != cudaSuccess) {
        fprintf(stderr, "cudaMemcpy failed!");
        goto error;
    }

    dim3 threadsmatrix(block_size, block_size);
    dim3 blocksmatrix(ceil((outsize) / (float)block_size / k), ceil((outsize) / (float)block_size));

    localkernel<<< blocksmatrix, threadsmatrix >>>(dev_tab, dev_out);

    // check for any errors launching the kernel
    cudastatus = cudagetlasterror();
    if (cudastatus != cudasuccess) {
        fprintf(stderr, "local launch failed: %s\n", cudageterrorstring(cudastatus));
        goto error;
    }
    
    // cudadevicesynchronize waits for the kernel to finish, and returns
    // any errors encountered during the launch.
    cudastatus = cudadevicesynchronize();
    if (cudastatus != cudasuccess) {
        fprintf(stderr, "cudadevicesynchronize returned error code %d after launching addkernel!\n", cudastatus);
        goto error;
    }

    cudastatus = cudamemcpy(out, dev_out, (outsize) * (outsize) * sizeof(float), cudamemcpydevicetohost);
    if (cudastatus != cudasuccess) {
        fprintf(stderr, "cudamemcpy failed!");
        goto error;
    }

    error:
    cudafree(dev_tab);
    cudafree(dev_out);
    
    return cudastatus;
}

cudaError_t sumLocalOldWithCuda(float* tab, float* out)
{
    float* dev_tab = 0;
    float* dev_out = 0;
    cudaError_t cudaStatus;

    cudaStatus = cudaSetDevice(0);
    if (cudaStatus != cudaSuccess) {
        fprintf(stderr, "cudaSetDevice failed!  Do you have a CUDA-capable GPU installed?");
        goto Error;
    }

    cudaStatus = cudaMalloc((void**)&dev_tab, N * N * sizeof(float));
    if (cudaStatus != cudaSuccess) {
        fprintf(stderr, "cudaMalloc failed!");
        goto Error;
    }

    cudaStatus = cudaMalloc((void**)&dev_out, (OUTSIZE) * (OUTSIZE) * sizeof(float));
    if (cudaStatus != cudaSuccess) {
        fprintf(stderr, "cudaMalloc failed!");
        goto Error;
    }

    cudaStatus = cudaMemcpy(dev_tab, tab, N * N * sizeof(float), cudaMemcpyHostToDevice);
    if (cudaStatus != cudaSuccess) {
        fprintf(stderr, "cudaMemcpy failed!");
        goto error;
    }

    dim3 threadsmatrix(block_size, block_size);
    dim3 blocksmatrix(ceil((outsize) / (float)block_size / k), ceil((outsize) / (float)block_size));

    localkernel << < blocksmatrix, threadsmatrix >> > (dev_tab, dev_out);

    // check for any errors launching the kernel
    cudastatus = cudagetlasterror();
    if (cudastatus != cudasuccess) {
        fprintf(stderr, "local launch failed: %s\n", cudageterrorstring(cudastatus));
        goto error;
    }

    // cudadevicesynchronize waits for the kernel to finish, and returns
    // any errors encountered during the launch.
    cudastatus = cudadevicesynchronize();
    if (cudastatus != cudasuccess) {
        fprintf(stderr, "cudadevicesynchronize returned error code %d after launching addkernel!\n", cudastatus);
        goto error;
    }

    cudastatus = cudamemcpy(out, dev_out, (outsize) * (outsize) * sizeof(float), cudamemcpydevicetohost);
    if (cudastatus != cudasuccess) {
        fprintf(stderr, "cudamemcpy failed!");
        goto error;
    }

error:
    cudafree(dev_tab);
    cudafree(dev_out);

    return cudastatus;
}
